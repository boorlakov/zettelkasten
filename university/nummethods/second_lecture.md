# Лекция №2

## Про число обусловленности

При использовании итерационных методов А* неизвестно. Но есть невязка

e = b - A x

Из формулы дроби выясняем, что A^{-1} e = A^{-1} b - A^{-1} A x = X* - x

Так получим, что формула на самом деле вида `(||X* - X||/||X*||) / (||b - Ax|| / ||b||)` по сути написано `<= ||A^{-1}|| ||A||`

Число обусловленности связь относительной невязки с относительной погрешностью

Получаем что погрешность что не превышает `отн невзяку` * на `число обусловленности`

Получаем 2 проблемы: как узнать число обусловленности (можно получить как число Тодда - это через спектральную норму), но чтобы найти минимальное собственное число у матрицы нужно слау штук 10, то есть это невыгодно

Как можно оценить число (только для итерационных)?

Но можем контролировать невязку (у зейделя автоматом все)

Фиксируем иксы и понижаем невязку на порядок (~10^-7), тогда мы надеемся, что x стал ближе к x*, `||x^k - x^n|| / ||x^k||`

Такая грубая оценка работает с точностью до порядка (понизили до 10^-7 а иксы изменились в 8 знаке, то все плохо)

## Про поиск собственных чисел

Есть матрица А, хотим найти собственные числа

Есть 2 глобальных подхода: (хотя все хуже)

Они все итерационные (прямых почти нет, они очень затратные)

1 класс - это когда все собств числа получаем разом

2 класс - это когда получаем собственное число, но только одно

### 1 класс

Он работает только в идеальных условиях

Ищем только у квадратных матриц:

Т.к. матрица представима в LU представлении

Пусть A_0 = L_0 U_0

A_1 = U_0 L_0

A_1 = L_1 U_1

...

A_k = U_{k-1} L_{k-1}

Матрица будет идти к диагональной матрице

Что можно делать с матрицей, чтобы собственные числа не менялись?

A = S B S^{-1} (ортогональное преобразование, тогда все сохранится)

Проверим эту связность с предыдущим объектом

A^{-1} = L_0 (U_0 L_0) L_0^{-1}

A_0 = L_0 A_1 L_0^{-1}

Должно ли это сходиться? - Нет никакой гарантии

Если и сходится, то медленно и дорого

Вообще этим алгоритмом в жизни никто не пользуется (по использованию памяти)

ЛУ это за куб потому что нужно квадрат элементов когда один элемент обрабатывается за линию

Способы разложение матрицы А разнятся, но в целом это слишком дорого по памяти

### 2 класс

Взяли вектор x_0 (any)

Итерационный шаг x_k = A x_{k-1}

И через какое-то время получим, собственный вектор

A x_k = lambda * x_k

Соотношение Реле

`lambda = (Ax_k, x_k) / (x_k, x_k)`

Останавливаемся только тогда, когда лямбда перестала меняться

Мы нашли максимальную лямбду

Проблема в том, что числа очень быстро растут

Решаем это таким образом: x_k = x_k / ||x_k||

Почему он работает?

#### Доказательство

Берем x_0 = с_1 е_1 + с_2 е_2 + ... + с_n e_n

A x_0 = c_1 A е_1 + с_2 A е_2 + ... + с_n A e_n = c_1 lambda_1 е_1 + с_2 lambda_2 е_2 + ... + с_n lambda_n e_n

A A x_0 = лямбда будет в квадрате

В конце концов в конце останется только максимальная лямбда

При нескольких одинаковых собственных значениях алгоритм работать не будет (он будет бесконечно идти)

с_1 = (x_0, e1)

x_0 := x_0 - (x_0, e1) e -- Назовем это коррекцией

Получим все равно лямбда_1, почему?

- Из-за конечной арифметики, из-за копления погрешности лямбда макс все равно вылезет

Но давайте все-таки корректировать на каждом шагу (так мы найдем ну всего лишь парочку лямбд). Все проблемы от конечной арифметики!

Научились искать максимальное

Теперь возьмемся за минимальное

x_k = A^-1 x_{k-1}

Ну уж нет, давайте

A x_k = x_{k-1}

B = (A - sigma * E)

lambda_B = lambda_A - sigma (сдвиг спектра матрицы)

Рассмотрим [-|lambda_{max}|; |lambda_{max}|]

Есть еще промежуток минимальных лямбд (внутри него точно ничего нет)

Берем правую часть делим пополам находим ближайшее (вычитаем этот отрезок) и тоже самое делаем с 2 новыми отрезками

В поиске резонанса может быть понадобится искать все собственные значения

## Про оценку лямбд

Теорема Гершголлена

Если матрица диагонально преобладающая, то в строке i радиус круга в центре диагонального элемента будет содержать собственное число
